<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Oracle Decompiler Example OracleRE</title>
</head>
<body>
<h1>Oracle Decompiler Example OracleRE.java File</h1>
<pre>package bbd.jportal.decompiler;<br><br>import java.util.*;<br>import java.io.*;<br>import java.sql.*;<br>import bbd.jportal.*;<br><br>class LinksTo<br>{<br>  String tableName;<br>  String linkName;<br>}<br><br>public class OracleRE<br>{<br>  protected static Database database;<br>  protected static Table table;<br>  protected static Field field;<br>  protected static Grant grant;<br>  protected static Key key;<br>  protected static Link link;<br>  protected static View view;<br>  protected static Proc proc;<br>  protected static Sequence sequence;<br>  protected static ConnectorOracle connector;<br>  protected static Vector tables;<br>  protected static Vector links;<br>  protected static Vector sequencesDone;<br>  protected static Oracle oracle;<br>  /**<br>  * parameters expected to be in the form user/password@sid.<br>  * If the sid contains : eg "hulk:1521:qa01" then "thin" will<br>  * be used for the connection else "oci7" will be used.<br>  */<br>  public static Database devolve(String parameters, PrintWriter outLog)<br>  {<br>    try<br>    {<br>      String userid, password, sid, driver;<br>      int slash = parameters.indexOf('/');<br>      int at = parameters.indexOf('@');<br>      if (slash == -1 || at == -1)<br>        return null;<br>      userid = parameters.substring(0, slash);<br>      password = parameters.substring(slash + 1, at);<br>      sid = parameters.substring(at + 1);<br>      if (sid.indexOf(':') != -1)<br>        driver = "thin";<br>      else<br>        driver = "oci7";<br>      connector = new ConnectorOracle(driver, sid, userid, password);<br>      oracle = new Oracle(connector);<br>      database = new Database();<br>      database.name = fixDatabaseName(sid);<br>      database.server = sid;<br>      database.userid = userid.toUpperCase();<br>      database.password = password.toUpperCase();<br>      sequencesDone = new Vector();<br>      loadTables(outLog);<br>      loadViews(outLog);<br>      loadSequences(outLog);<br>    } catch (SQLException e)<br>    {<br>      System.out.println(sqlExceptionMessage(e));<br>      System.out.flush();<br>      e.printStackTrace();<br>      return null;<br>    } catch (ClassNotFoundException e)<br>    {<br>      System.out.println(e.toString());<br>      System.out.flush();<br>      e.printStackTrace();<br>      return null;<br>    } catch (Throwable e)<br>    {<br>      e.printStackTrace();<br>      return null;<br>    }<br>    return database;<br>  }<br>  static String fixDatabaseName(String sid)<br>  {<br>    int i = sid.indexOf(':');<br>    if (i == -1)<br>      return sid.toUpperCase();<br>    String name = sid.substring(0, i);<br>    sid = sid.substring(i + 1);<br>    i = sid.indexOf(':');<br>    if (i != -1)<br>    {<br>      name = name + sid.substring(0, i);<br>      sid = sid.substring(i + 1);<br>    }<br>    name = name + sid;<br>    return name.toUpperCase();<br>  }<br>  static String sqlExceptionMessage(SQLException e)<br>  {<br>    return "\n\nSQLException thrown"<br>      + "\n  SQL State  "<br>      + e.getSQLState()<br>      + "\n  Error Code "<br>      + e.getErrorCode()<br>      + "\n  Message    "<br>      + e.getMessage();<br>  }<br>  static String setKorM(int value)<br>  {<br>    if ((value % 1024) != 0 || (value / 1024) == 0)<br>      return String.valueOf(value);<br>    int kvalue = value / 1024;<br>    if ((kvalue % 1024) != 0 || (kvalue / 1024) == 0)<br>      return String.valueOf(kvalue) + "K";<br>    int mvalue = kvalue / 1024;<br>    return String.valueOf(mvalue) + "M";<br>  }<br>  static String caseChange(String input, int ch)<br>  {<br>    String result = input.substring(0, 1).toUpperCase();<br>    input = input.substring(1);<br>    int n = input.indexOf(ch);<br>    while (n != -1)<br>    {<br>      result = result + input.substring(0, n);<br>      input = input.substring(n + 1);<br>      if (input.length() == 0)<br>        break;<br>      result = result + input.substring(0, 1).toUpperCase();<br>      input = input.substring(1);<br>      n = input.indexOf(ch);<br>    }<br>    return result + input;<br>  }<br>  static String caseChange(String input)<br>  {<br>    return caseChange(<br>      caseChange(caseChange(input.toLowerCase(), '_'), '#'),<br>      '$');<br>  }<br>  static void loadTables(PrintWriter outLog) throws SQLException<br>  {<br>    Oracle.Tables tablesRec = oracle.getTables();<br>    Query query = tablesRec.tables(database.userid);<br>    tables = new Vector();<br>    while (tablesRec.tables(query))<br>    {<br>      table = new Table();<br>      table.database = database;<br>      table.name = tablesRec.tableName;<br>      table.alias = caseChange(table.name);<br>      table.options.addElement(<br>        "TABLESPACE "<br>          + tablesRec.tableSpaceName<br>          + " STORAGE (INITIAL "<br>          + setKorM(tablesRec.initialExtent)<br>          + " NEXT "<br>          + setKorM(tablesRec.nextExtent)<br>          + ")");<br>      outLog.println(table.name);<br>      outLog.flush();<br>      loadTableFields(outLog);<br>      loadTablePrimaryKey(outLog);<br>      loadTableUniqueKeys(outLog);<br>      loadTableIndexes(outLog);<br>      loadTableForeignKeys(outLog);<br>      loadTableGrants(outLog);<br>      buildStdProcs(outLog);<br>      tables.addElement(table);<br>    }<br>    Oracle.ForeignLinks foreignLinksRec = oracle.getForeignLinks();<br>    query = foreignLinksRec.foreignLinks(database.userid);<br>    links = new Vector();<br>    while (foreignLinksRec.foreignLinks(query))<br>    {<br>      LinksTo linkTo = new LinksTo();<br>      linkTo.tableName = foreignLinksRec.tableName;<br>      linkTo.linkName = foreignLinksRec.linkName;<br>      links.addElement(linkTo);<br>    }<br>    for (int i = 0; i &lt; links.size(); i++)<br>    {<br>      LinksTo linkTo = (LinksTo) links.elementAt(i);<br>      descend(linkTo.tableName, 0, outLog);<br>    }<br>    for (int i = 0; i &lt; tables.size(); i++)<br>    {<br>      table = (Table) tables.elementAt(i);<br>      database.tables.addElement(table);<br>    }<br>  }<br>  static void descend(String tableName, int depth, PrintWriter outLog)<br>  {<br>    if (depth &gt; 20)<br>    {<br>      outLog.println("Possible Cycle on TABLE  " + tableName);<br>      return;<br>    }<br>    for (int i = 0; i &lt; links.size(); i++)<br>    {<br>      LinksTo linkTo = (LinksTo) links.elementAt(i);<br>      if (linkTo.tableName.compareTo(tableName) &lt; 0)<br>        continue;<br>      if (linkTo.tableName.compareTo(tableName) &gt; 0)<br>        break;<br>      descend(linkTo.linkName, depth + 1, outLog);<br>    }<br>    for (int i = 0; i &lt; tables.size(); i++)<br>    {<br>      table = (Table) tables.elementAt(i);<br>      if (table.name.compareTo(tableName) &lt; 0)<br>        continue;<br>      if (table.name.compareTo(tableName) &gt; 0)<br>        break;<br>      database.tables.addElement(table);<br>      tables.removeElementAt(i);<br>      break;<br>    }<br>  }<br>  static void buildStdProcs(PrintWriter outLog)<br>  {<br>    table.hasStdProcs = true;<br>    buildInsert(outLog);<br>    if (table.hasPrimaryKey)<br>    {<br>      buildUpdate(outLog);<br>      buildDeleteOne(outLog);<br>      buildSelectOne(outLog);<br>      buildExists(outLog);<br>    }<br>    buildDeleteAll(outLog);<br>    buildSelectAll(outLog);<br>    buildCount(outLog);<br>  }<br>  static void buildInsert(PrintWriter outLog)<br>  {<br>    proc = new Proc();<br>    proc.table = table;<br>    proc.name = "Insert";<br>    table.buildInsert(proc);<br>    table.procs.addElement(proc);<br>  }<br>  static void buildUpdate(PrintWriter outLog)<br>  {<br>    proc = new Proc();<br>    proc.table = table;<br>    proc.name = "Update";<br>    table.buildUpdate(proc);<br>    table.procs.addElement(proc);<br>  }<br>  static void buildDeleteOne(PrintWriter outLog)<br>  {<br>    proc = new Proc();<br>    proc.table = table;<br>    proc.name = "DeleteOne";<br>    table.buildDeleteOne(proc);<br>    table.procs.addElement(proc);<br>  }<br>  static void buildExists(PrintWriter outLog)<br>  {<br>    proc = new Proc();<br>    proc.table = table;<br>    proc.name = "Exists";<br>    table.buildExists(proc);<br>    table.procs.addElement(proc);<br>  }<br>  static void buildSelectOne(PrintWriter outLog)<br>  {<br>    proc = new Proc();<br>    proc.table = table;<br>    proc.name = "SelectOne";<br>    table.buildSelectOne(proc, false);<br>    table.procs.addElement(proc);<br>  }<br>  static void buildDeleteAll(PrintWriter outLog)<br>  {<br>    proc = new Proc();<br>    proc.table = table;<br>    proc.name = "DeleteAll";<br>    table.buildDeleteAll(proc);<br>    table.procs.addElement(proc);<br>  }<br>  static void buildSelectAll(PrintWriter outLog)<br>  {<br>    proc = new Proc();<br>    proc.table = table;<br>    proc.name = "SelectAll";<br>    table.buildSelectAll(proc, false, false);<br>    table.procs.addElement(proc);<br>  }<br>  static void buildCount(PrintWriter outLog)<br>  {<br>    proc = new Proc();<br>    proc.table = table;<br>    proc.name = "Count";<br>    table.buildCount(proc);<br>    table.procs.addElement(proc);<br>  }<br>  static void loadTableFields(PrintWriter outLog) throws SQLException<br>  {<br>    Oracle.TableSequence tableSequenceRec = oracle.getTableSequence();<br>    Vector sequenceFields = new Vector();<br>    Vector typeCFields = new Vector();<br>    String sequenceName = table.name + "SEQ";<br>    Query query1 =<br>      tableSequenceRec.tableSequence(database.userid, table.name, sequenceName);<br>    while (tableSequenceRec.tableSequence(query1))<br>      sequenceFields.addElement(tableSequenceRec.columnName);<br>    Oracle.TableTypeC tableTypeCRec = oracle.getTableTypeC();<br>    Query query3 = tableTypeCRec.tableTypeC(database.userid, table.name);<br>    while (tableTypeCRec.tableTypeC(query3))<br>    {<br>      String condition = tableTypeCRec.condition;<br>      if (condition.indexOf("IS NOT NULL") == -1)<br>        typeCFields.addElement(condition);<br>    }<br>    Oracle.TableColumns tableColumnsRec = oracle.getTableColumns();<br>    Query query2 = tableColumnsRec.tableColumns(database.userid, table.name);<br>    while (tableColumnsRec.tableColumns(query2))<br>    {<br>      field = new Field();<br>      field.name = tableColumnsRec.columnName;<br>      field.alias = caseChange(field.name);<br>      boolean usedSeq =<br>        fieldType(<br>          (sequenceFields.indexOf(field.name) != -1) ? true : false,<br>          tableColumnsRec.dataType,<br>          tableColumnsRec.dataLength,<br>          tableColumnsRec.dataPrecision,<br>          tableColumnsRec.dataScale);<br>      if (usedSeq)<br>      {<br>        table.hasSequence = true;<br>        sequencesDone.addElement(sequenceName);<br>      }<br>      field.isNull = (tableColumnsRec.nullable.compareTo("Y") == 0);<br>      if (tableColumnsRec.defaultLength != -1)<br>        field.defaultValue = tableColumnsRec.defaultValue;<br>      for (int i = 0; i &lt; typeCFields.size(); i++)<br>      {<br>        String condition = (String) typeCFields.elementAt(i);<br>        if (condition.indexOf(field.name + " ") == 0)<br>          field.checkValue = condition;<br>      }<br>      table.fields.addElement(field);<br>    }<br>  }<br>  static boolean fieldType(<br>    boolean isSeqField,<br>    String dataType,<br>    int dataLength,<br>    int dataPrecision,<br>    int dataScale)<br>  {<br>    boolean result = false;<br>    if (dataType.compareTo("NUMBER") == 0)<br>    {<br>      if (dataScale &lt; 0 || dataPrecision &lt; 0)<br>      {<br>        field.type = Field.FLOAT;<br>        field.length = 8;<br>        field.precision = 0;<br>        field.scale = 0;<br>      } else if (dataScale &gt; 0)<br>      {<br>        field.type = Field.FLOAT;<br>        field.length = 8;<br>        field.precision = dataPrecision;<br>        field.scale = dataScale;<br>      } else if (dataPrecision &gt; 10)<br>      {<br>        field.type = Field.LONG;<br>        field.length = 8;<br>        field.precision = dataPrecision;<br>        field.scale = 0;<br>      } else if (dataPrecision &gt; 5)<br>      {<br>        if (isSeqField)<br>        {<br>          field.type = Field.SEQUENCE;<br>          result = true;<br>        } else<br>          field.type = Field.INT;<br>        field.length = 4;<br>        field.precision = dataPrecision;<br>        field.scale = 0;<br>      } else if (dataPrecision &gt; 3)<br>      {<br>        field.type = Field.SHORT;<br>        field.length = 2;<br>        field.precision = dataPrecision;<br>        field.scale = 0;<br>      } else<br>      {<br>        field.type = Field.BYTE;<br>        field.length = 1;<br>        field.precision = dataPrecision;<br>        field.scale = 0;<br>      }<br>    } else if (dataType.compareTo("DATE") == 0)<br>    {<br>      field.type = Field.DATETIME;<br>      field.length = 14;<br>    } else // treat all else as char<br>      {<br>      field.type = Field.CHAR;<br>      field.length = dataLength;<br>    }<br>    return result;<br>  }<br>  static void loadTablePrimaryKey(PrintWriter outLog) throws SQLException<br>  {<br>    Oracle.TablePrimaryKey tablePrimaryKeyRec = oracle.getTablePrimaryKey();<br>    if (tablePrimaryKeyRec.tablePrimaryKey(database.userid, table.name))<br>    {<br>      key = new Key();<br>      key.name = tablePrimaryKeyRec.constraintName;<br>      key.isPrimary = true;<br>      table.hasPrimaryKey = true;<br>      Oracle.ConstraintColumns constraintColumnsRec = oracle.getConstraintColumns();<br>      Query query = constraintColumnsRec.constraintColumns(database.userid, key.name);<br>      while (constraintColumnsRec.constraintColumns(query))<br>      {<br>        table.setPrimary(constraintColumnsRec.column);<br>        key.fields.addElement(constraintColumnsRec.column);<br>      }<br>      Oracle.GetIndexTableSpace getIndexTableSpaceRec = oracle.getGetIndexTableSpace(); <br>      if (getIndexTableSpaceRec.getIndexTableSpace(database.userid, key.name))<br>        key.options.addElement(<br>          "USING INDEX TABLESPACE "<br>            + getIndexTableSpaceRec.tableSpaceName<br>            + " STORAGE (INITIAL "<br>            + setKorM(getIndexTableSpaceRec.initialExtent)<br>            + " NEXT "<br>            + setKorM(getIndexTableSpaceRec.nextExtent)<br>            + ")");<br>      table.keys.addElement(key);<br>    }<br>  }<br>  static void loadTableUniqueKeys(PrintWriter outLog) throws SQLException<br>  {<br>    Oracle.TableUniqueKeys tableUniqueKeysRec = oracle.getTableUniqueKeys();<br>    Query query1 = tableUniqueKeysRec.tableUniqueKeys(database.userid, table.name);<br>    while (tableUniqueKeysRec.tableUniqueKeys(query1))<br>    {<br>      key = new Key();<br>      key.name = tableUniqueKeysRec.constraintName;<br>      key.isUnique = true;<br>      Oracle.ConstraintColumns constraintColumnsRec = oracle.getConstraintColumns();<br>      Query query2 = constraintColumnsRec.constraintColumns(database.userid, key.name);<br>      while (constraintColumnsRec.constraintColumns(query2))<br>        key.fields.addElement(constraintColumnsRec.column);<br>      Oracle.GetIndexTableSpace getIndexTableSpaceRec = oracle.getGetIndexTableSpace();<br>      if (getIndexTableSpaceRec.getIndexTableSpace(database.userid, key.name))<br>        key.options.addElement(<br>          "USING INDEX TABLESPACE "<br>            + getIndexTableSpaceRec.tableSpaceName<br>            + " STORAGE (INITIAL "<br>            + setKorM(getIndexTableSpaceRec.initialExtent)<br>            + " NEXT "<br>            + setKorM(getIndexTableSpaceRec.nextExtent)<br>            + ")");<br>      table.keys.addElement(key);<br>    }<br>  }<br>  static void loadTableIndexes(PrintWriter outLog) throws SQLException<br>  {<br>    Oracle.TableIndexes tableIndexesRec = oracle.getTableIndexes();<br>    Query query1 = tableIndexesRec.tableIndexes(database.userid, table.name);<br>    while (tableIndexesRec.tableIndexes(query1))<br>    {<br>      key = new Key();<br>      key.name = tableIndexesRec.indexName;<br>      Oracle.IndexColumns indexColumnsRec = oracle.getIndexColumns();<br>      Query query2 = indexColumnsRec.indexColumns(database.userid, key.name);<br>      while (indexColumnsRec.indexColumns(query2))<br>        key.fields.addElement(indexColumnsRec.column);<br>      key.options.addElement(<br>        "TABLESPACE "<br>          + tableIndexesRec.tableSpaceName<br>          + " STORAGE (INITIAL "<br>          + setKorM(tableIndexesRec.initialExtent)<br>          + " NEXT "<br>          + setKorM(tableIndexesRec.nextExtent)<br>          + ")");<br>      table.keys.addElement(key);<br>    }<br>  }<br>  static void loadTableForeignKeys(PrintWriter outLog) throws SQLException<br>  {<br>    Oracle.TableForeignKeys tableForeignKeysRec = oracle.getTableForeignKeys();<br>    Query query1 = tableForeignKeysRec.tableForeignKeys(database.userid, table.name);<br>    while (tableForeignKeysRec.tableForeignKeys(query1))<br>    {<br>      link = new Link();<br>      link.name = tableForeignKeysRec.rTableName;<br>      link.linkName = tableForeignKeysRec.constraintName;<br>      Oracle.ConstraintColumns constraintColumnsRec = oracle.getConstraintColumns();<br>      Query query2 = constraintColumnsRec.constraintColumns(database.userid, link.linkName);<br>      while (constraintColumnsRec.constraintColumns(query2))<br>        link.fields.addElement(constraintColumnsRec.column);<br>      table.links.addElement(link);<br>    }<br>  }<br>  static void loadTableGrants(PrintWriter outLog) throws SQLException<br>  {<br>    Oracle.TableGrants tableGrantsRec = oracle.getTableGrants();<br>    Query query1 = tableGrantsRec.tableGrants(database.userid, table.name);<br>    while (tableGrantsRec.tableGrants(query1))<br>    {<br>      grant = new Grant();<br>      grant.perms.addElement(tableGrantsRec.privilege);<br>      grant.users.addElement(tableGrantsRec.grantee);<br>      table.grants.addElement(grant);<br>    }<br>  }<br>  static void loadViews(PrintWriter outLog) throws SQLException<br>  {<br>    Oracle.Views viewsRec = oracle.getViews();<br>    Query query1 = viewsRec.views(database.userid);<br>    while (viewsRec.views(query1))<br>    {<br>      view = new View();<br>      view.name = viewsRec.name;<br>      String text = viewsRec.text;<br>      while (text.indexOf("\n") != -1)<br>      {<br>        int n = text.indexOf("\n");<br>        String line = text.substring(0, n);<br>        text = text.substring(n + 1);<br>        view.lines.addElement(line);<br>      }<br>      Oracle.ViewColumns viewColumnsRec = oracle.getViewColumns();<br>      Query query2 = viewColumnsRec.viewColumns(database.userid, view.name);<br>      while (viewColumnsRec.viewColumns(query2))<br>        view.aliases.addElement(viewColumnsRec.column);<br>      database.views.addElement(view);<br>    }<br>  }<br>  static void loadSequences(PrintWriter outLog) throws SQLException<br>  {<br>    try<br>    {<br>      Oracle.Sequences sequencesRec = oracle.getSequences();<br>      Query query1 = sequencesRec.sequences(database.userid);<br>      while (sequencesRec.sequences(query1))<br>      {<br>        outLog.println(sequencesRec.name);<br>        outLog.flush();<br>        if (sequencesDone.indexOf(sequencesRec.name) != -1)<br>          continue;<br>        sequence = new Sequence();<br>        sequence.name = sequencesRec.name;<br>        sequence.minValue = (int) sequencesRec.minValue;<br>        if (sequencesRec.maxValue &lt; 1000000000)<br>          sequence.maxValue = (int) sequencesRec.maxValue;<br>        else<br>          sequence.maxValue = 999999999;<br>        sequence.increment = (int) sequencesRec.increment;<br>        sequence.cycleFlag = (sequencesRec.cycleFlag.compareTo("Y") == 0);<br>        sequence.orderFlag = (sequencesRec.orderFlag.compareTo("Y") == 0);<br>        if (sequencesRec.startWith &lt; 1000000000)<br>          sequence.startWith = (int) sequencesRec.startWith;<br>        else<br>          sequence.startWith = 0;<br>        database.sequences.addElement(sequence);<br>      }<br>    } catch (SQLException e)<br>    {<br>      outLog.println(sqlExceptionMessage(e));<br>      outLog.flush();<br>    }<br>  }<br>}<br></pre>
</body>
</html>
